`번역 :` https://codeburst.io/javascript-double-equals-vs-triple-equals-61d4ce5a121a

## 문제

JavaScript는 두 가지 _시각적으로_ 유사하지만 **매우 다른** 방식으로 평등을 테스트합니다. 당신은 `==`또는 `===` 과 함께 equality를 테스트 할수 있습니다. 차이점은 다음과 같습니다.

## Triple Equals

JavaScript에서 triple equals `===`를 사용할 때 **엄격한** 평등을 테스트합니다 . 이것은 우리가 비교 하고 있는 **타입** 과 **값** 이 같아야 한다는 것을 의미합니다 .

엄격한 평등의 몇 가지 예를 살펴 보겠습니다.

이 첫 번째 예에서 우리는 숫자 5와 숫자 5를 비교해보겠다. 예상대로 `true`반환됩니다. 둘 다 **숫자** 이며, 둘 다 5 의 동일한 **값** 을 공유합니다.

```
5 === 5   
// 참
```

이를 염두에두고 우리는 `true`를 반환 할 두 가지 예제를 살펴볼 수 있습니다.

```
'hello world'=== 'hello world'   
// true (양쪽 **문자열** , 같은 **값** )

**true === true**  
 // true (두 **부울 값** , 같은 **값** )
```

 이제 `false`를 반환 할 몇 가지 예제를 살펴 보겠습니다.

이 예제에서 우리는 숫자 77과 문자열 77 과 비교합니다. 즉, 피연산자는 **같은 값**이지만 **다른 유형을** 갖습니다 . 이것은 `false` 을 리턴 할 것입니다.

```
77 === '77'
// 거짓 (숫자 v. 문자열)
```

다음은 두 가지 추가 예제입니다.

```
'cat'=== 'dog'
 // false (둘 다 String이지만 다른 값을 가짐)

false === 0  
 // false (다른 유형 및 다른 값)
```
 다시 말하면,  트리플 (엄격한) 평등을 위한 주요 특성은 우리가 비교 하고있는 **유형** 과 **값**  모두 가 동일해야한다는 것입니다.

## Double equals

자바 스크립트에서 double equals를 사용할 때 우리는 **느슨한 평등** 를 합니다 **Double equals는** 유형 강제 변환도 수행 합니다.

유형 강제 변환은 두 값을 공통 유형으로 변환 한 후에 만 비교한다는 것을 의미합니다.

예를 들겠습니다. 우리가 엄격한 동등성을 가지고 다음을 테스트했을 때 이전에 회상 해보십시오 :

```
77 === '77'
// false (숫자 v. 문자열)
```

`77`과 `'77'`은 유형이 다르므로 엄격하게 동일하지 않습니다 . 그러나 우리가 느슨한 평등를 가지고이 값들을 테스트한다면 ...

```
77 == '77'
// true
```

`true`를 얻을 수 있다. 그것은 타입 강제 때문이다.  JavaScript는 실제로 우리의 값을 같은 유형으로 변환하려고 시도합니다. 이 경우 성공합니다. 문자열 값은 `'77'`은  숫자 값으로 쉽게 변환 될 수 있습니다 `77`. 이후로 `77` 과  `77`을 비교합니다. 그래서 `true` 을 얻을 수 있습니다.

한 가지 더 예제를 살펴 보겠습니다.

엄격한 테스트를 진행했던 false와 0을 다시 기억해보십쇼.

```
false === 0  
 // false (다른 유형 및 다른 값)
```

이것은 분명히 거짓입니다. 그러나, 우리가 같은 방정식을 루스 평등으로 실행한다면 ...

```
false == 0   
// true
```

우리는 얻을 수 `true`있습니다. 왜 그런걸까요?  자바 스크립트에서 **falsy** 한 값 과 관련이 있습니다. 다음 절에서이 개념을 살펴 보겠습니다.

## Falsy Value

좋아, 그럼 왜 자바 스크립트에서 `false == 0` 입니까? 복잡하지만 JavaScript `0`는 **falsy** 한 값 이기 때문에 입니다.

타입 강제 변환은 사실 우리의 0을 false boolean으로 변환 한 다음 `false`동일합니다 `false`.

자바 스크립트 에는 단지 **6 개의 falsy values**가 있습니다.


-   `false`- 부 울린 거짓
-   `0` - 숫자 0
-   `“”` - 빈 문자열
-   `null`
-   `undefined`
-   `NaN` - 숫자가 아님

## Falsy Value Comparison

다음은 falsy values의 '규칙'입니다. JavaScript로 자주 작업하는 경우 암기해야 할 것들입니다.

1.  `false`, `0`및`""`

우리의 처음 세 거짓 값 중 하나를 느슨한 평등과 비교할 때, 항상 같을 것입니다! 이 값들은 모두 `false`부울 로 강제 변환되기 때문 입니다.

```
false == 0
// true

0 == ""
 // true

""== false
 // true
```

2. `null`및`undefined`

비교할 경우 `null`와 `undefined`, 그들은 단지 자신과 동일한 서로 있습니다 :

```
null == null  
// true

undefined == undefined  
// true

null == undefined  
// true
```

`null`다른 값과 비교하려고 하면 반환 `false`됩니다.

3. `NaN`

마지막으로, `NaN`무엇이든 동등하지 않습니다. 

```
NaN == null  
// false

NaN == undefined  
// false

**NaN == NaN**  
// false
```

## 주요 요점

-   보시다시피, 강제 타입은 JS작업에서 미치게 할 수 있습니다.  JavaScript에 익숙하지 않으면 느슨한 평등는 더 많은 골칫거리가 될 수 있습니다. 여섯 가지 위선적 인 가치와 그와 관련된 규칙을 암기하면 느슨한 평등을 이해하는 데 큰 도움이됩니다.
-   **Triple Equals는 double equals보다 우수합니다. 가능할 때마다 평등을 테스트하기 위해 Triple Equals를 사용해야합니다. type과 value를 테스트함으로써 항상 진정한 평등성 테스트를 수행하고 있음을 확신 할 수 있습니다.**
