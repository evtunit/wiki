# 클로저

JavaScript는 매우 함수 지향적인 언어입니다.  
그것은 우리에게 많은 자유를 줍니다.  
함수는 동적으로 생성 되거나 다른 변수에 복사되거나, 다른 함수에 인수로 전달되어 나중에 전혀 다른곳에서 호출 될 수 있습니다.

우리는 함수가 외부 변수에 접근 할 수 있다는 것을 알고 있습니다. 이 기능은 자주 사용됩니다.  

그러나 외부 변수가 변경되면 무슨 일이 일어납니까?
함수가 가장 최근의 값 또는 함수가 생성 되었을 때 존재했던 값을 얻습니까?  

또한 함수가 코드의 다른 위치로 이동하여 호출 될 때에는 어떤 일이 발생합니까?  
새로운 장소의 외부 변수에 접근할 수 있습니까?  

다른 언어는 여기서 다르게 작동하지만 이 챕터에서 우리는 JavaScript의 동작을 다룰겁니다.

## 몇 가지 질문  
먼저 두 가지 상황을 고려한 후 내부 역할을 하나씩 살펴보면 다음 질문과 더 복잡한 질문에 대답을 할 수 있습니다.
1. sayHi 함수는 외부 변수 이름을 사용합니다. 함수가 실행 될때 어떤 값을 사용할까요? 
````
let name = "John";

function sayHi() {
  alert("Hi, " + name);
}

name = "Pete";

sayHi(); // what will it show: "John" or "Pete"?
````
이러한 상황은 브라우저 및 서버 사이드 개발부분에서 공통입니다.  
함수는 예를 들어 사용자 작업 또는 네트워크 요청 후 생성 된 것보다 나중에 실행 될 수 있도록 예약 될 수 있습니다.  
질문 : 최신 변경 사항이 있습니까?  

2. makeWorker 함수는 다른 함수를 만들어 리턴합니다. 그 새로운 기능은 다른 곳에서 호출 될 수 있습니다.  
   생성 장소, 호출 장소 둘 다 외부 변수에 접근 할 수 있습니까?
````
function makeWorker() {
  let name = "Pete";

  return function() {
    alert(name);
  };
}

let name = "John";

// create a function
let work = makeWorker();

// call it
work(); // what will it show? "Pete" (name where created) or "John" (name where called)?
````

## Lexical Environment(어휘 환경)
무슨 일이 일어나고 있는지 이해하기 위해서 먼저 변수가 실제로 무엇인지 알아 봅시다.
JavaScript에서는 모든 실행중인 함수, 코드블록 및 스크립트 전체가 Lexical Environment(어휘 환경)라고 알려진  
내부(숨겨진) 관련 객체를 가지고 있습니다.  

Lexical Environment(어휘 환경) 객체는 다음 두 부분으로 구성됩니다.
1. Environment Record(환경 기록) - 모든 로컬 변수를 속성으로 저장하는 객체
2. 외부 lexical environment(어휘 환경)에 대한 참조, 외부 코드와 관련된 것

변수는 특별한 내부 객체인 Environment Record(환경 기록)의 속성 일 뿐입니다.

예를 들어, 이 간단한 코드에는 Lexical Environment가 하나만 있습니다.  
![](https://javascript.info/article/closure/lexical-environment-global.svg)  

이것은 전체 스크립트와 관련된 글로벌 Lexical Environment 라고 불립니다.
위 그림에서 사각형은 Environment Record (가변 저장소)를 의미하고 화살표는 외부 참조를 의미합니다.  
글로벌 Lexical Environment(어휘 환경)에는 외부 참조가 없어 null을 가리킵니다.  

변수가 정의되고 할달 될 때 변경되는 방식입니다.  
![](https://javascript.info/article/closure/lexical-environment-global-2.svg)  

오른쪽의 사각형은 실행 중 글로벌 Lexical Environment(어휘 환경)이 어떻게 변하는 지 보여주고 있습니다.  
1. 스크립트가 시작될 때, Lexical Environment(어휘 환경)은 비어 있습니다.  
2. let phrase 이 나타납니다. 값이 지정되지 않았으므로 undefined가 저장됩니다.
3. phrase에 값이 할당 됩니다.
4. phrase 값이 변경됩니다.  

지금은 모든것이 단순해 보입니다.  
요약
* 변수는 현재 실행중인 블록 / 함수 / 스크립트 와 관련된 특별한 내부 객체의 속성입니다.  
* 변수 작업은 실제로 해당 객체의 속성을 사용 하는 것입니다.  

### 함수 선언 
지금까지는 변수만 관찰 했습니다. 이제 함수 선언을 입력하세요.  
let 변수와 달리, 실행이 변수에 도달 했을 때가 아니라 Lexical Environment이 생성되었을 때 완전히 초기화 됩니다.  
최상위 기능의 경우 스크립트가 시작되는 순서를 의미합니다.  
그렇기 때문에 정의하기 전에 함수 선언을 호출 할 수 있습니다.  
아래 코드는 Lexical Environment가 처음부터 비어 있지 않음을 보여줍니다.  
그것은 함수 선언이기 때문입니다. 그리고 나중에 let으로 선언 된 phrase를 얻습니다.  
![](https://javascript.info/article/closure/lexical-environment-global-3.svg) 

### 내외부 Lexical Environment
이제 함수가 외부 변수에 접근 할 때 어떤 일이 발생하는지 살펴 보겠습니다.
호출 중에 say()는 회부 변수 phrase를 사용합니다.  
진행 상황에 대해 자세히 살펴 보겠습니다.  
함수가 실행되면 새로운 Lexical Environment가 자동으로 작성되어 호출의 로컬 변수 및 매개 변수를 저장합니다.  
예를 들어 say("John")의 경우 다음과 같습니다. 
![](https://javascript.info/article/closure/lexical-environment-simple.svg)  

따라서 함수 호출 중에는 내부 환경(함수 호출의 경우) 과 외부 환경(글로벌)의 두가지 Lexical Environment이 있습니다.  
* 내부 Lexical Environment은 현재 실행중인 내용에 해당 합니다.  
  함수 인수인 'name'이라는 단일 속성이 있습니다. 우리는 say("John")를 호출했고 name의 값은 "John"입니다.  
* 외부 Lexical Environment는 글로벌 Lexical Environment 입니다.  
  변수 phrase와 함수 자체가 있습니다.  

내부 Lexical Environment에는 외부 Lexical Environment에 대한 참조가 있습니다. 
코드가 변수에 접근하려고 할 때, 내부 Lexical Environment가 먼저 검색된 다음 외부 Lexical Environment,  
그 다음 Lexical Environment 등 글로벌 Lexical Environment까지 검색이 됩니다.  
만약 변수를 어디에서도 찾을 수 없다면 strict 모드에서 오류가 발생합니다.   
(strict 모드 사용없이 user="John" 과 같이 존재하지 않는 변수에 할당하면 새로운 전역 변수 user가 생성됩니다.)  
이 예에서 검색이 어떻게 진행이 되는지 봅시다. 
* 내부 경고가 이름에 접근하려고 할 때 Lexical Environment 기능에서 즉시 발견합니다.  
* phrase에 접근하려는 경우 로컬에 phrase가 없으므로 주변 Lexical Environment에 대한 참조를 따라 해당 phrase를 찾습니다.  
![](https://javascript.info/article/closure/lexical-environment-simple-lookup.svg)  

이제 우리는 챕터 시작부분의 첫 질문에 대한 답을 얻을 수 있습니다.  
함수는 현재 외부 변수를 가져 오며 가장 최근 값을 사용합니다.  
이전 변수 값은 어디에도 저장되지 않습니다.  
함수가 변수를 원하면 자체 Lexical Environment 또는 외부 Lexical Environment에서 현재 값을 가져옵니다.  
첫 번째 질문에 대한 답은 Pete 입니다.
````
let name = "John";

function sayHi() {
  alert("Hi, " + name);
}

name = "Pete"; // (*)

sayHi(); // Pete
````
위 코드의 실행 흐름
1. 글로벌 Lexical Environment가 가진 name은 "John" 입니다.  
2. (*) 행에서 전역 변수가 변경 되었습니다. 이제부터 name은 "Pete" 입니다.  
3. sayHi() 함수가 실행되면 외부에서 이름을 가져옵니다.  
   이곳에서는 이미 "Pete"입니다. 글로벌 Lexical Environment에서 가져온 것입니다.  
