### Intro
---

늘 어떤 데이터 유형이 있는지 확인 하는 것은 쉬운 일은 아니다. 언어 자체는 직설적인 방식으로 작용하는 유형의 연산자를 제공한다.
typeof는 데이터유형을 문자열로 반환하므로 객체일 경우 `"객체"`가 반환되고 문자열 일 경우 `"스트링"`이 반환된다.

그러나 Javascripts 데이터 유형과 연산자 유형은 완벽하지 않다. 예를 들어 어레이의 경우 null > `"object"`가 반환되고 NaN 및 Infinity의 경우 `"number"`가 반환된다. 실제로 어떤 값이 숫자, 문자열, null인지, 배열인지 알기 위해서는 조금 더 많은 이해와 논리가 필요하다

<br>

### Table of contents
---

**String**

String은 항상 String이기 때문에 타입체크 하기가 쉽다. 새 문자열(new string) 유형으로 호출할 경우 대신 `"객체"`가 반환된다. 따라서 이러한 문자열을 포함하기 위해 아래처럼 사용할 수 있다.

```js
// Returns if a value is a string
function isString (value) {
  return typeof value === 'string' || value instanceof String;
}
```

<br>

**Number**

typeof에서 일반 숫자 가 아닌 다른 것들은 NaN 및 Infinity와 같은 `"숫자"`를 반환한다. 값이 실제로 숫자인지 알아 보려면 [isFinite](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/isFinite) 함수가 필요하다.


```js
// Returns if a value is really a number
function isNumber (value) {
return typeof value === 'number' && isFinite(value);
  }
```

<br>

**Array**

In javascript arrays are not true arrays like in java and in other languages. They're actually objects so typeof will return "object" for them. To know if something's really an array its constructor can be compared to Array.

```js
// Returns if a value is an array
function isArray (value) {
  return value && typeof value === 'object' && value.constructor === Array;
}

// ES5 actually has a method for this (ie9+)
Array.isArray(value);
```

<br>

**Function**

Functions are functions so here just typeof is enough.

```js
// Returns if a value is a function
function isFunction (value) {
  return typeof value === 'function';
}
```

<br>

**Object**

Many things are objects in javascript. To know if a value is an object that can have properties and be looped through, its constructor can be compared to Object. It doesn't work for objects created from classes, then the instanceof operator can be used instead.

```js
// Returns if a value is an object
function isObject (value) {
  return value && typeof value === 'object' && value.constructor === Object;
}
```

<br>

**Null & undefined**

Most times you don't need to check explicitly for null and undefined since they're both falsy values. However to do it below functions does the trick.

```js
// Returns if a value is null
function isNull (value) {
  return value === null;
}

// Returns if a value is undefined
function isUndefined (value) {
  return typeof value === 'undefined';
}
```

<br>

**Boolean**

For booleans typeof is enough since it returns "boolean" for both true and false.

```js
// Returns if a value is a boolean
function isBoolean (value) {
  return typeof value === 'boolean';
}
```

<br>

**RegExp**

RegExp's are objects so the only thing needed to check is if the constructor is RegExp.

```js
// Returns if a value is a regexp
function isRegExp (value) {
  return value && typeof value === 'object' && value.constructor === RegExp;
}
```

<br>

**Error**

Errors in javascript are the same as "exceptions" in many other programming languages. They come in a couple different forms like for instance Error, TypeError and RangeError. An instanceof statement is enough for them all, but just to be extra sure we also check for the "message" property that errors have.

```js
// Returns if value is an error object
function isError (value) {
  return value instanceof Error && typeof value.message !== 'undefined';
}
```

<br>

**Date**

Date isn't really a data type in javascript. But to know if something's a Date object it can be checked with instanceof.

```js
// Returns if value is a date object
function isDate (value) {
  return value instanceof Date;
}
```

<br>

**Symbol**

In ES6 the new datatype Symbol was added. Nicely enough typeof returns "symbol" for it so no more logic is required.

```js
// Returns if a Symbol
function isSymbol (value) {
  return typeof value === 'symbol';
}
```