## 모든 자바스크립트 개발자가 알아야하는 부동소수점 숫자

> 참고 : Floating Points은 부동소수점이라 부른다.

자바스크립트에 대한 강연을 한 이후에(정말로, 나는 내가 낸 책에 부끄러워 하지 않고 말한다. - [Underhanded JavaScript](https://leanpub.com/underhandedjavascript)와 이것의 대체한 책인 - [JavaScript Techinical Interview Questions](https://leanpub.com/jsinterviewquestions?utm_source=Blog&utm_medium=Blog&utm_term=jsfloat&utm_content=jsfloat&utm_campaign=jsfloat-blog)), 그 자리에서 Q&A 세션이 있었다. 
나는 대부분의 질문에 대답할 수 있었으나 khalid hilaby의 자바스크립트 number 타입에 대한 질문에 대해 흥미롭고 일반적인 질문을 하였다. 
그는 단순히 자바스크립트의 float에 대해 훨씬 더 많이 아는 것을 원했었다. 그리고 왜 그들이 이상한 반응을 보였는지 알고 싶었다. 
나는 이 질문에 대답하는 동안에, 나는 이 대답이 충분하지 않은 느낌이 들었다.
나는 부동 소수점의 구조에 대한 설명을 하기 위해 Go의 "Pointer Tagging"이라는 기사를 실었다. 해당 기사에는 부동 소수점의 산술에 대한 설명과 옛날에는 부동소수점(FPUs)에 대한 특수한 CPU를 사용 해야만 했다는 내용을 기술 하였다.  

지금 나는 시드니로 돌아왔고, 휴식을 취했으니 다시 한번 더 이 질문에 대해 생각해보려고 한다. 그 결과가 Flippin Awesome에 기사로 존재한다. (What Every JavaScript Developer Should Know About Floating Points )
이 글은 Flippin Awesome에 올리기 전의 전체 버젼이다. 

> 참고 : 
현재 What Every JavaScript Developer Should Know About Floating Points에 걸려진 링크는 없어진 페이지로 보임 또한 Flippin Awesome에 글을 올리려면 길이와 내용이 적합한지 등등 체크를 진행한 것으로 번역으로 추측함.

이 기사에서는 독자들이 base-2의 base-10 숫자에 익숙하다고 가정한다.(i.e. 1은 1<sub>b</sub>, 2는 10<sub>b</sub>, 3은 11<sub>b</sub>, 4는 100<sub>b</sub> 등등). 
이 기사에서는 숫자의 표현이 10진법이란 단어는 숫자의 십진법을 가리킨다. (예,2.718)
"이진"이라는 단어는 기계표현을 가리킨다. 

여기에서 "base-10", "base-2"으로 쓰인다. 

> 참고 : 여기에서 "base-10"은 10진수, "base-2"은 2진수라고 가르키는 것 같음...

### Floating Points (부동 소수점)
To figure out what a floating point is, we first start with the idea that there are many kinds of numbers, which we will go through. We call 1 is an integer - it is a whole number with no fractional values in it.
부동 소수점이 무엇인지 알기 위해 우리는 첫번째로 많은 숫자의 종류가 있다는 것에서 시작해야하고 우리는 이를 진행할 것이다.  우리는 1은 정수라 부른다. - 이것은 분수값이 없는 정수이다. 

½은 분수라고 불린다. 이것은 1을 2로 나누고 있다는 것을 암시한다. 분수는 부동 소수점을 설명하는데 매우 중요한 개념이다. 

<span style="background-color: #FFFF00">0.5</span>는 일반적으로 10진수로 알려져있다. 그러나 매우 중요한 구분이 필요한데, 이 는 
<span style="background-color: #FFFF00">0.5</span>는 실제로 분율 1⁄2의 십진수(base-10) 표현이다. 위치 표기법이라고 부르는 이것은 base-10 숫자로 쓸 때 1/2를 나타내는 방법이다.

분수에 대한 표현의 숫자가 유한하기 때문에 <span style="background-color: #FFFF00">0.5</span>를 유한 표현이라고 부른다. <span style="background-color: #FFFF00">0.5</span>에서 <span style="background-color: #FFFF00">5</span>이후의 숫자는 더 이상 없다. 예를 들어 무한 표현은 1/3을 나타낼 때 <span style="background-color: #FFFF00">0.33333</span>이다. 이 아이디어는 나중에 중요한 아이디어가 된다 
 
정수, 분수 또는 소수 표기법 이외의 숫자를 나타내는 다른 방법들도 존재한다. 
이전에 실제로 본적이 있을 것이다. 
이것은 6.022 x 10<sup>23</sup>*와 같은 것을 봤다. 이것은 표준화된 형식으로 알려진 과학적 표기법으로 알려져 있다. 
이 형식은 아래의 수식처럼 일반화 할 수 있다. 

D<sub>1</sub>.D<sub>2</sub>D<sub>3</sub>D<sub>4</sub>...D<sub>p</sub> x B<sup>E</sup>

일반적인 양식을 부동소수점이라 부른다. 

D, D1.D2D3D4…D의 <sub>p</sub> 자릿수 시퀀스를 <i>Significands<i> 또는 <i>Mantissa</i>라고 합니다. <span style="background-color: #FFFF00">p</span>는 정밀도(<i>Precision</i>)라고 하는 중요한 숫자의 수이다. 위의 간단한 아보가드로의 수의 경우 <span style="background-color: #FFFF00">p</span>을 <span style="background-color: #FFFF00">4</span>로 하자. 
(그리고 표기법의 일부이고, 여기서 곱셈 기호는 *이다. )

기본 숫자 다음에 지수(<i>Exponent</i>)가 나온다. 지수는 양수 또는 음수일 수 있다. 

부동 소수점의 장점은 어떤 수를 나타내는데도 사용될 수 있다는 것이다. 
예를 들어 정수 1은 1.0*10<sup>0</sup>으로 나타낼 수 있다. 빛의 속도는 초당 2.99792458 x 10<sup>6</sup>m으로 나타낼 수 있다. 1/2은 base-2에 0.1 * 2<sup>0</sup>으로 나타낼 수 있다. 

### The Radix Point (라딕스 포인트)
위의 마지막 예가 이상해보였다면, 그것은 우리가 일반적으로 base-2에서 분수 표현을 본 적이 없기 때문이다. 

라딕스 포인트로 분수를 이진수로 표현하는 방법에 대해 알려주려한다. 

하지만 10진 표현부터 살펴뵤자. 왜 1/2이 0.5일까? 학교에서 긴 나눗셈을 배웠지 않나?
학교에서 배운 나눗셈 또한 왜 1/2이 0.5인지 설명하는 방법이었고, 단순히 1을 2로 나누었을 뿐이다. 
<div style="width:100px;font-family:monospace; font-size:larger; margin:10px 10px 10px 10px;" id="longdivision">
<div style="clear:both;">
&nbsp;&nbsp;&nbsp;0.5
</div>
<div style="clear:both;">
<div style="border-right: 1px black solid; border-radius: 0px 0px 10px 0px; display:table-cell">
2
</div>
<div style="border-top: 1px black solid; display:table-cell">
&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;
</div>
</div>
<div style="border-bottom: 1px black solid;clear:both;">
&nbsp;&nbsp;&nbsp;0
</div>
<div style="clear:both;"> &nbsp;&nbsp;&nbsp;1 0</div>
<div style="border-bottom: 1px black solid;clear:both;">
&nbsp;&nbsp;&nbsp;1 0&nbsp;&nbsp;
</div>
</div>

분수를 보는 또 다른 방법은 분수를 숫자 기반과 지수적 관점에서 보는 것이다. 1/2은 5/10처럼 분모로 10<sup>1</sup>을 사용하여 분수로 표현할 수 있다. 

사실, 분수를 라딕스 포인트로 정교하게 표현할 수 있는지 여부를 결정하는 것이 규칙이다. 분모를 분수로 표현하고 분모로 지수화할 수 있다면 라딕스 포인트 표기법으로 정교하게  표현될 수 있다. 

위치 표기법 뒤에 있는 아이디어는 간단하다. 예를 들어보자. <span style="background-color: #FFFF00">19.95</span> (해당 글의 작성자의 고려중인 책의 가격)의 숫자에 대해 생각해보자. 이는 다음과 같은 위치로 나눌 수 있다. 
<div style="width:400px;font-family: monospace; display: table; border-collapse: collapse; font-size: 16px; margin-bottom:3px;">
<div style="display:table-cell; border-left:1px solid #000; border-right:1px solid #000; border-bottom: 1px solid #000; text-align:center; width:90px">
1
</div>
<div style="display:table-cell; border-left:1px solid #000; border-right:1px solid #000; border-bottom: 1px solid #000; text-align:center; width:90px">
9
</div>
<div style="display:table-cell; border-left:1px solid #000; border-right:1px solid #000; border-bottom: 1px solid #000; text-align:center; width:40px">
.
</div>
<div style="display:table-cell; border-left:1px solid #000; border-right:1px solid #000; border-bottom: 1px solid #000; text-align:center; width:90px">
9
</div>
<div style="display:table-cell; border-left:1px solid #000; border-right:1px solid #000; border-bottom: 1px solid #000; text-align:center; width:90px">
5
</div>
</div>
<div style="width:400px;font-family: monospace; display: table; border-collapse: collapse; font-size: 16px; margin-bottom:10px;">
<div style="display:table-cell; text-align:center; width:90px">
10<sup>1</sup>
</div>
<div style="display:table-cell; text-align:center; width:90px">
10<sup>0</sup>
</div>
<div style="display:table-cell; text-align:center; width:40px">
.
</div>
<div style="display:table-cell; text-align:center; width:90px">
10<sup>-1</sup>
</div>
<div style="display:table-cell; text-align:center; width:90px">
10<sup>-2</sup>
</div>
</div>
이는 <span style="background-color: #FFFF00">10</span> 단위의 위치에 <span style="background-color: #FFFF00">1</span>, <span style="background-color: #FFFF00">1</span> 단위 위치에서 <span style="background-color: #FFFF00">9</span> , <span style="background-color: #FFFF00">0.1</span> 단위의 위치에 <span style="background-color: #FFFF00">9</span> , <span style="background-color: #FFFF00">0.01</span> 단위의 위치에 <span style="background-color: #FFFF00">5</span> 가 있다는 것을 의미한다. 

 This concept can likewise be extended to base-2 numbers. Instead of powers of 10, the positional notation for base-2 numbers have powers of 2 as the positions. It is for this reason why 10 in base-2 is 2, and why 100 in base-2 is 4.

To detemine if a number can be finitely expressed in base-2, the same method as above applies - check to see if the fraction can be expressed with a denominator that is a power of 2. Let’s take a simple example: 0.75. 0.75 can be expressed as 3⁄4, of which 4 is 100 in base-2. So it can be written as: 11⁄100. We know then that this can be finitely expressed as 0.11. Doing long division with base-2 numbers too yield the same result.

There is also a short-cut method to convert from decimal to base-2 radix point representation, which I for quick mental estimation:

Take non-integral part of the the decimal and multiply it by 2: 0.75 * 2 = 1.50.
Reserve the integral part of the result - 1. The base-2 radix point representation now reads 0.1
The the non-integral part of the result and multiply it by 2: 0.5 * 2 = 1.00.
Repeat 2 and 3 until finished*: The radix point now reads 0.11
Replace any integral part of the original decimal with the base-2 equivalent.
Now, try it for yourself with either methods, the fraction 1⁄10. Interesting results isn’t it? This will be important later on.

Removing the Radix Point
In the above examples, we’re still quite tied to having a radix point (the dot in the number). This presents some problems when it comes to representing something in binary. Given an arbitrary floating point, say π, we can represent it as a floating point as such: 3.14159 x 100. In a base-2 representation, it would look something like this: 11.00100100 001111…. Assuming that the number is represented in a 16 bit manner, this means the digits would be laid out in the machine like this: 11001001000011111. The question now is this: where is the radix point supposed to be? This doesn’t even yet involve the exponent (we implicitly assume the base is base-2).

What about if the number was 5.14159? The integral part would be 101 instead of 11, requiring one more bit field. Of course, we could specify that the first n bits of the field belong to the integer part (i.e. the left of the radix point), and the rest belongs to the fractional parts, but that’s the topic for another article about fixed point numbers.

Once we remove the radix point, then we only have two things to keep track of: the exponent and the mantissa. We can remove the radix point by applying a transformation formula, making the generalized floating point look like this:

(이미지 필요)
D1D2D3D4...Dp ⁄ Bp-1 x BE

This is where we derive most of our binary floating points from. Note that the significand is now an integer. This makes it far simpler to store a floating point number in a machine. In fact, the most widely used method of representing floating points in binary is with the IEEE 754 format.

IEEE 754
The representation of floating points in JavaScript follows the format as specified in IEEE-754. Specifically it is a double-precision format, meaning that 64 bits are allocated for each floating point. Although it is not the only way to represent floating points in binary, it is by far the most widely used format*. The format is represented in 64-bits of binary like so:

(이미지 필요)
s	eeeeeee eeee	ffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff
1	11	52
Of the 64 bits available, 1 bit is used for the sign - whether a number is positive or not. 11 bits are used for the exponent - this allows for up to 1023 as an exponent. The reason for this is because the exponent actually uses something called offset binary encoding to encode negative numbers. What this basically means is that if all 11 bit fields are set to 0 (the decimal equivalent is 0), the exponent is actually -1023 in decimal. When all 11 bit fields are set to 1 (the decimal equivalent is 2047), the exponent is actually 1024 in decimal. The exponent of 2047 is actually reserved for special numbers, as described below.

The remaining 52 bits are allocated for the mantissa. Even that is interesting. Look through a list of scientific constants - they’re all written in scientific notation. Notice that to the left of the radix point, there is usually only one non-zero digit. This is called the nomalized form. Likewise with floating points, there is a concept of having a normalized form - in fact, floating points are stored in the normalized form in binary according to the IEEE-754 standard. However, there is an interesting feature when storing the normalized form.

Let us consider the fraction 3⁄4. In base-2, it is written 0.11. This is not the normalized form. The normalized form is written 1.1 x 2-1 - recall that the integral part of the positional notation cannot be 0 in the normalized form. It is the normalized form that is stored according to the specification.

Because in base-2, digits can only either be 0 or 1, the normalized form of the floating point always have the form of 1.xxxx x 2E. This is a convenient feature - you wouldn’t need to store the first digit - it’s implied to be always 1. This gives one whole extra bit of precision. So the mantissa always stores the bit beginning after the radix point. In the case of 3⁄4, the mantissa is 1000000000000000000000000000000000000000000000000000. Laid out in memory, this is what 3⁄4 looks like:

(이미지 필요)
0	0111111 1111	1000 00000000 00000000 00000000 00000000 00000000 00000000


The specification also allows for special numbers. Both infinity and NaN for example, is encoded as 2047 in the exponent, with the mantissa ranging from 1 (the last mantissa field is 1) to 4503599627370495 (all the mantissa fields are 1) for NaNs and 0 in the mantissa field for infinity. Any number in the mantissa field is ignored when the exponent is 2047. Since all pointers are only 48-bits in size, this allows for some really cool hacking - such as storing pointers inside NaNs.

This floating point format also explains why in JavaScript, there exists +0 and -0 as well as +Infinity and -Infinity - the sign bit in the front denotes that. The IEEE-754 specification also specifies that NaN will always compare unordered to any operand, even with itself, which is why in JavaScript, NaN === NaN will yield false.

If ever you want to look at how numbers are encoded in JavaScript, the IEEE 754 Decimal Converter is actually a good site to check out.

Rounding Errors
With the introduction to floating points done, we now enter a more prickly topic - rounding errors. It is the bane of all developers who develop with floating point numbers, JavaScript developers doubly so, because the only number format available to JavaScript developers are floating point numbers.

It was mentioned earlier that fractions like ⅓ cannot be finitely represented in base-10. This is actually true for all numbers represented in any base. For example, in base-2 numbers, 1⁄10 cannot be finitely represented. It is represented as 0.000110011001100110011…. Note that 0011 is infinitely repeating. It is because of this particular quirk that causes rounding errors.

But first, a primer on rounding errors. Consider one of the most famous irrational numbers, Pi: 3.141592653589793…. Most people remember the first 5 mantissa (3.1415) really well* - that’s an example of rounding down, which we will use for this example. The rounding error can hence calculated as such:
(이미지 필요)
(R - A) ⁄ Bp-1
Where R stands for the rounded number, and A stands for the actual number. B is the base as previously seen, as was p, which is the precision. So the oft-remembered Pi has a rounding error of: 0.00009265…).

While this does not sound quite as severe, let’s try this idea with base-2 numbers. Consider the fraction 1⁄10. In base-10, it’s written as 0.1. In base-2, it is: 0.00011001100110011…. Assuming we round to just 5 mantissa, it’d be written as 0.0001. But 0.0001 in binary is actually 1⁄16 (or 0.0625)! This means there is a rounding error of 0.0375, which is rather large. Imagine doing basic mathematics like 0.1 + 0.2, and the answer returns 0.2625!

Fortunately, the floating point specification that ECMAScript uses specifies up to 52 mantissa (making it 53 bits of information with some clever hacking), so the rounding errors are quite small. In fact the specification actually goes into the details of the errors, and using a fascinating metric called the ulp (units in last place) to define the precision of the floating point. Because conducting arithmetic operations on floating points causes errors to build up over time, the IEEE 754 specification also comes specific algorithms for mathematical operations.

However, it should be noted that despite all that, the associative property of binary operations (like addition, subtraction, multiplication and subtraction) are not guaranteed when dealing with floating points, even at high precision ones. What I mean by that is ((x + y) + a + b) is not neccessarily equal to ((x + y) + (a + b)).

And that is the cause of the bane of JavaScript developers. For example, in JavaScript, 0.1 + 0.2 === 0.3 will yield false. Hopefully, by now you would know why. What is worse of course, is the fact that rounding errors add up with each successive mathematical operation performed on it.

Handling Floating Points in JavaScript
I have one suggestion as tho how to handle floating points in JavaScript: don’t. But of course, given that JavaScript is such a shit language and only has one numerical type, it is unavoidable. There have been plenty of suggestions, both good and bad, when it comes to dealing with JavaScript numbers. Most of these suggestions have to do with rounding numbers in JavaScript before or after binary operations.

The worst advice I’ve actually heard so far is to “expect floating point rounding errors, and duct tape around it”. The advice then follows on to say - if you expect 0.1 to be 0.10000000000000001 then work as if you’re working with 0.10000000000000001 all the time. I mean, wtf is with that kind of ridiculous advice??! Sorry, but that’s plain dumb.

Another suggestion - one that isn’t actually too bad on the surface but shows all sorts of problems once you’ve given it some thought - is storing everything as an integer number (not the type) for operations, and then formatting it for display. An example can be seen as used by Stripe - the amounts are stored in cents. This has a notable problem - not all currencies in the world are actually decimal (Mauritiana). There too exists currencies in the world where there are no subunits (Japanese Yen) or non-100 subunits (Jordanian Dinars), or more than one subunits (Chinese Renminbi). Eventually, you’d just recreate the floating point. Probably poorly too.

The best suggestions I’ve seen to handle floating points is to use properly tested libraries like sinfuljs or mathjs for handling them. I personally prefer mathjs (but really, for anything mathematics related I wouldn’t even go near JavaScript). BigDecimal is also extremely useful when arbitrary precision math needs to be done.

Another oft-repeated advice is to use the built-in toPrecision() and toFixed() methods on numbers. A big warning to anyone thinking of using them - those methods return strings. So if you have something like:

```javascript
function foo(x, y) {
    return x.toPrecision() + y.toPrecision()
}

>foo(0.1, 0.2)
"0.10.2"
```
The built in methods toPrecision() and toFixed() are really only for display purposes. Use with caution! Now go forth and multiply (safely)!

Conclusion
JavaScript numbers are really just floating points as specified by IEEE-754. Due to inadequecies when representing numbers in base-2, as well as a finite machine, we are left with a format that is filled with rounding errors. This article explains those rounding errors and why errors occur. Always use a good library for numbers instead of building your own. If you are interested to read more about floating points, I highly recommend the fairly awesome Handbook of Floating Point Arithmetic. It’s a bit pricey and a bit difficult to read, but if you take your time with it, it will come through.

Another book that is actually a good and very difficult read is Modern Computer Arithmetic. I haven’t finished it - I mainly skipped the proofs and used it for reference.

If you’re interested comparing floats, the seminal paper is one written by Bruce Dawson. It’s a must-read if you serious about comparing floating points (but really, don’t do it. I’ve done it and it was terrible). In fact, Bruce Dawson’s body of work is quite good a read - they are scattered everywhere on the Internet though, so you will have to go find it yourself.

Incidentally, this topic on floating points also covered in my books (Underhanded JavaScript and its alternate title: JavasScript Technical Interview Questions) - with a little bit more detail on representation of numbers and the like. I hadn’t originally wanted to address floating points, but on the flight back I wrote a long chapter on it while figuring out how to write this article. So if you liked this article, do buy the damn book :P

### 느낀점
- (이 느낀점은 번역을 하다가 중간에 ... ) 음 ... 이 전 번역이 정말 수월 했구나... 하는 ... 
- (이 느낀점은 번역을 하다가 중간에 ... ) 해당 번역을 진행하면서 마크다운 작성법 일부를 또 알게 됨. 윗첨자 ```<sup><sup>```, 아래첨자 ```<sub></sub>```, ```<div><div>``` 로 감싸고 인라인으로 스타일을 줄 수도 있다...
- (이 느낀점은 번역을 하다가 중간에 ... ) 한번 스터디를 진행하다가 부동소수점 관련 질문으로 인해 머리를 굴려가며 찾고, 설명한 적이 있었는데 다시 봐도 새로운 느낌이다 ... 스터디 진행시 메모 해둔 것이 어딧더라 ... 하며 뒤적이다 ... 포기쓰 ... 하지만 중요한 건 부동 소수점을 잘 못 계산하면 안되는 예를 하나 들자면 한국 통화는 우리들에게 익숙한 정수형으로도 표현이 대체적으로 가능하지만 외국 통화는 소수점으로 떨어지는 경우가 있기 때문에 결제 시스템 구축할 때는 통화 단위를 계산하는 과정이 있다면 소수점 자리도 고려하여 코드를 짜야할 것 같다. (외국 통화 단위로 결제 개발을 하시는 분에게 들었던 적이 있고, 이 분께서 부동 소수점이 무엇이냐, 이걸 왜 써야하냐며 역으로 질문도 받은 적이...) 타입스크립트를 만약 사용하게 되면 타입을 강제적으로 하기 때문에 이와 같은 오류는 조금 줄일 수는 있지 않을까 ... 하는 생각 ... (언제...타입 스크립트를 스타트하지...) 