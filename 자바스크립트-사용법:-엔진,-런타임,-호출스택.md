자바스크립트는 많은 인기와 관심이 많아지면서 프론트엔드, 백엔드, 하이브리드앱, 임베디드 디바이스 등등 높은 레벨에 대한 활용을 지지하고 있다
더 좋은 코드를 작성하기 위해 좀 더 깊게 자바스크립트를 이해하기 위한 문서!

경쟁력을 유지하기 위해 성능이 우수해야 하는 [SessionStack](https://www.sessionstack.com/?utm_source=medium&utm_medium=source&utm_content=javascript-series-post1-intro)을 구축할 때 사용하는 몇 가지 규칙이 있다

[GitHut](https://githut.info/)에서도 보듯 자바스크립트는 Github 의 Active Repositories 와 Total Pushes에서 1위를 차지하고 있습다. 다른 범주에서도 크게 뒤떨어져 있지는 않죠.

![](https://cdn-images-1.medium.com/max/800/1*Zf4reZZJ9DCKsXf5CSXghg.png)

(최신 GitHub 언어 순위)

프로젝트가 자바스크립트의 의존도가 높다면 좋은 소포트웨어를 만들기 위해 언어에 대해 깊이 이해를 해야하고 언어적 특성과 내부 구조를 정확하게 이해해야 한다. 많은 자바스크립트 개발자들이 매일 자바스크립트를 사용하고 있지만 실제로 기본적인 동작원리가 어떻게 일어나는지 알지 못하는 개발자가 많다고 한다

<br>

## Overview
아마 모든 사람들이 V8엔진에 대해 들어보았고 대부분의 사람들이 자바스크립트는 싱글쓰레드 언어거나 콜백 큐를 사용하는걸 알고있다. 

해당 포스트는 모든 개념을 살펴보고 자바스크립트가 어떻게 실행되는지 알아보도록 하고, 이 글을 다 읽고 나면 자바스크립트 내장 API를 효율적으로 사용하는 non-blocking 앱을 구현할 수 있을것이다.

만약 자바스크립트에 비교적 익숙하지 않다면 왜 다른 언어에 비해 이상한 언어인지 깨닫게 될 것 이다. 숙련된 자바스크립트 개발자라면 여러분이 매일 사용하는 자바스크립트 런타임 작동 방식에 대한 새로운 통찰력을 얻을 수 있을 것이다.

<br>

## The JavaScript Engine
대표적인 예로 자바스크립트 엔진으로 구글의 V8엔진을 꼽는다. V8엔진은 크롬과 Node.js 내부에서 사용이 된다.

![](https://cdn-images-1.medium.com/max/800/1*OnH_DlbNAPvB9KLxUCyMsA.png)

엔진은 다음 두 가지 주요 구성 요소로 구성된다.

**Memory Heap** - 메모리 할당이 이루어 지는 곳

**Call Stack** — 코드 실행에 따라 호출 스택이 쌓이는 곳

<br>

## The Runtime
모든 자바스크립트 개발자가 setTimeout 같은 브라우저 내장 API를 사용하게 된다. 엔진에 의해 제공되지 않는다

그럼 도대체 어디서 오는걸까?

사실 좀 더 복잡하다.

![](https://cdn-images-1.medium.com/max/800/1*4lHHyfEhVB0LnQ3HlhSs8g.png)

자바스크립트 엔진 이외에도 관여해야할 것이 많다. DOM, AJAX, setTimeout과 같이 브라우저 내장 API를 Web API라고 한다.
그리고  **event loop**, **callback queue.*도 있다


## The Call Stack
자바스크립트는 싱글쓰레드 프로그래밍 언어이다. 호출스택이 하나이다. 따라서 한 작업에 하나만 처리할 수 있다.
호출스택은 프로그래밍에서 어디에 있는지 기록하는 자료구조이다. 함수를 실행하면 호출스택의 맨 위에 놓인다. 함수의 실행이 끝나면 호출스택에서 제거를 하는게 스택의 역할이다.

아래코드를 보자.

```js
function multiply(x, y) {
    return x * y;
}
function printSquare(x) {
    var s = multiply(x, x);
    console.log(s);
}
printSquare(5);
```

엔진이 실행하는 시점에서 호출스택은 비워져있다. 나중에 코드가 실행이 되면서 호출스택은 아래와 같이 변하게 된다

![](https://cdn-images-1.medium.com/max/800/1*Yp1KOt_UJ47HChmS9y7KXw.png)

호출스택의 단계를 **Stack Frame**이라 부른다.


And this is exactly how stack traces are being constructed when an exception is being thrown — it is basically the state of the Call Stack when the exception happened. Take a look at the following code:

```js
function foo() {
    throw new Error('SessionStack will help you resolve crashes :)');
}
function bar() {
    foo();
}
function start() {
    bar();
}
start();
```
If this is executed in Chrome (assuming that this code is in a file called foo.js), the following stack trace will be produced:

![](https://cdn-images-1.medium.com/max/800/1*T-W_ihvl-9rG4dn18kP3Qw.png)

**“Blowing the stack”** — this happens when you reach the maximum Call Stack size. And that could happen quite easily, especially if you’re using recursion without testing your code very extensively. Take a look at this sample code:
```js
function foo() {
    foo();
}
foo();
```
When the engine starts executing this code, it starts with calling the function “foo”. This function, however, is recursive and starts calling itself without any termination conditions. So at every step of the execution, the same function gets added to the Call Stack over and over again. It looks something like this:

![](https://cdn-images-1.medium.com/max/800/1*AycFMDy9tlDmNoc5LXd9-g.png)

At some point, however, the number of function calls in the Call Stack exceeds the actual size of the Call Stack, and the browser decides to take action, by throwing an error, which can look something like this:

![](https://cdn-images-1.medium.com/max/800/1*e0nEd59RPKz9coyY8FX-uw.png)

Running code on a single thread can be quite easy since you don’t have to deal with complicated scenarios that are arising in multi-threaded environments — for example, deadlocks.

But running on a single thread is quite limiting as well. Since JavaScript has a single Call Stack, **what happens when things are slow?**


## Concurrency & the Event Loop
What happens when you have function calls in the Call Stack that take a huge amount of time in order to be processed? For example, imagine that you want to do some complex image transformation with JavaScript in the browser.

You may ask — why is this even a problem? The problem is that while the Call Stack has functions to execute, the browser can’t actually do anything else — it’s getting blocked. This means that the browser can’t render, it can’t run any other code, it’s just stuck. And this creates problems if you want nice fluid UIs in your app.

And that’s not the only problem. Once your browser starts processing so many tasks in the Call Stack, it may stop being responsive for quite a long time. And most browsers take action by raising an error, asking you whether you want to terminate the web page.

![](https://cdn-images-1.medium.com/max/800/1*WlMXK3rs_scqKTRV41au7g.jpeg)

Now, that’s not the best user experience out there, is it?

So, how can we execute heavy code without blocking the UI and making the browser unresponsive? Well, the solution is asynchronous callbacks.

This will be explained in greater detail in Part 2 of the “How JavaScript actually works” tutorial: “[Inside the V8 engine + 5 tips on how to write optimized code](https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e)”.

In the meantime, if you’re having a hard time reproducing and understanding issues in your JavaScript apps, take a look at SessionStack. SessionStack records everything in your web apps: all DOM changes, user interactions, JavaScript exceptions, stack traces, failed network requests, and debug messages.

With SessionStack, you can replay issues in your web apps as videos and see everything that happened to your user.

There’s a free plan, no credit card is required. [Get started now](https://www.sessionstack.com/solutions/developers/?utm_source=medium&utm_medium=blog&utm_content=Post-1-overview-getStarted).

![](https://cdn-images-1.medium.com/max/800/1*kEQmoMuNBDfZKNSBh0tvRA.png)


출처: [How JavaScript works: an overview of the engine, the runtime, and the call stack](https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf)