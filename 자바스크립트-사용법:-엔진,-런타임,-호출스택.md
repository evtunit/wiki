자바스크립트는 많은 인기와 관심이 많아지면서 프론트엔드, 백엔드, 하이브리드앱, 임베디드 디바이스 등등 높은 레벨에 대한 활용을 지지하고 있다
더 좋은 코드를 작성하기 위해 좀 더 깊게 자바스크립트를 이해하기 위한 문서!

경쟁력을 유지하기 위해 성능이 우수해야 하는 [SessionStack](https://www.sessionstack.com/?utm_source=medium&utm_medium=source&utm_content=javascript-series-post1-intro)을 구축할 때 사용하는 몇 가지 규칙이 있다

[GitHut](https://githut.info/) 통계에서 자바스크립트는 GitHub의 Active Repository, Total Pushs에서 상위에 있음

![](https://cdn-images-1.medium.com/max/800/1*Zf4reZZJ9DCKsXf5CSXghg.png)

(최신 GitHub 언어 통계).

프로젝트가 자바스크립트의 의존도가 높다면 좋은 소포트웨어를 만들기 위해 언어에 대해 깊이 이해를 해야하고, 모든 것을 활용해야 한다.
매일 자바스크립트를 사용하고 있지만 hood 아래에서 무슨 일이 일어나는지 알지 못하는 개발자가 많다. 고로 알려주겠음!

<br>

## Overview
거의 모든 사람들이 V8엔진에 대해 들어보았고 대부분의 사람들이 자바스크립트는 싱글쓰레드 언어거나 콜백 큐를 사용하는걸 알고있다. 해당 포스트는 모든 개념을 살펴보고 자바스크립트가 어떻게 실행되는지 설명하도록 하며, 만약 당신이 자바스크립트에 비교적 익숙하지 않다면, 이 블로그 게시물은 왜 자바스크립트가 다른 언어와 비교했을 때 그렇게 "이상한"지를 이해하는데 도움이 될 것이다.

숙련된 자바스크립트 개발자라면 여러분이 매일 사용하는 자바스크립트 런타임의 실제 작동 방식에 대한 새로운 통찰력을 얻을 수 있을 것이다.

<br>

## The JavaScript Engine
A popular example of a JavaScript Engine is Google’s V8 engine. The V8 engine is used inside Chrome and Node.js for example. Here is a very simplified view of what it looks like:
![](https://cdn-images-1.medium.com/max/800/1*OnH_DlbNAPvB9KLxUCyMsA.png)
The Engine consists of two main components:
* Memory Heap — this is where the memory allocation happens
* Call Stack — this is where your stack frames are as your code executes


## The Runtime
There are APIs in the browser that have been used by almost any JavaScript developer out there (e.g. “setTimeout”). Those APIs, however, are not provided by the Engine.

So, where are they coming from?

It turns out that the reality is a bit more complicated.
![](https://cdn-images-1.medium.com/max/800/1*4lHHyfEhVB0LnQ3HlhSs8g.png)

So, we have the Engine but there is actually a lot more. We have those things called Web APIs which are provided by browsers, like the DOM, AJAX, setTimeout and much more.

And then, we have the so popular **event loop** and the **callback queue.**


## The Call Stack
JavaScript is a single-threaded programming language, which means it has a single Call Stack. Therefore it can do one thing at a time.

The Call Stack is a data structure which records basically where in the program we are. If we step into a function, we put it on the top of the stack. If we return from a function, we pop off the top of the stack. That’s all the stack can do.

Let’s see an example. Take a look at the following code:

```js
function multiply(x, y) {
    return x * y;
}
function printSquare(x) {
    var s = multiply(x, x);
    console.log(s);
}
printSquare(5);
```

When the engine starts executing this code, the Call Stack will be empty. Afterwards, the steps will be the following:

![](https://cdn-images-1.medium.com/max/800/1*Yp1KOt_UJ47HChmS9y7KXw.png)

Each entry in the Call Stack is called a **Stack Frame.**

And this is exactly how stack traces are being constructed when an exception is being thrown — it is basically the state of the Call Stack when the exception happened. Take a look at the following code:

```js
function foo() {
    throw new Error('SessionStack will help you resolve crashes :)');
}
function bar() {
    foo();
}
function start() {
    bar();
}
start();
```
If this is executed in Chrome (assuming that this code is in a file called foo.js), the following stack trace will be produced:

![](https://cdn-images-1.medium.com/max/800/1*T-W_ihvl-9rG4dn18kP3Qw.png)

**“Blowing the stack”** — this happens when you reach the maximum Call Stack size. And that could happen quite easily, especially if you’re using recursion without testing your code very extensively. Take a look at this sample code:
```js
function foo() {
    foo();
}
foo();
```
When the engine starts executing this code, it starts with calling the function “foo”. This function, however, is recursive and starts calling itself without any termination conditions. So at every step of the execution, the same function gets added to the Call Stack over and over again. It looks something like this:

![](https://cdn-images-1.medium.com/max/800/1*AycFMDy9tlDmNoc5LXd9-g.png)

At some point, however, the number of function calls in the Call Stack exceeds the actual size of the Call Stack, and the browser decides to take action, by throwing an error, which can look something like this:

![](https://cdn-images-1.medium.com/max/800/1*e0nEd59RPKz9coyY8FX-uw.png)

Running code on a single thread can be quite easy since you don’t have to deal with complicated scenarios that are arising in multi-threaded environments — for example, deadlocks.

But running on a single thread is quite limiting as well. Since JavaScript has a single Call Stack, **what happens when things are slow?**


## Concurrency & the Event Loop
What happens when you have function calls in the Call Stack that take a huge amount of time in order to be processed? For example, imagine that you want to do some complex image transformation with JavaScript in the browser.

You may ask — why is this even a problem? The problem is that while the Call Stack has functions to execute, the browser can’t actually do anything else — it’s getting blocked. This means that the browser can’t render, it can’t run any other code, it’s just stuck. And this creates problems if you want nice fluid UIs in your app.

And that’s not the only problem. Once your browser starts processing so many tasks in the Call Stack, it may stop being responsive for quite a long time. And most browsers take action by raising an error, asking you whether you want to terminate the web page.

![](https://cdn-images-1.medium.com/max/800/1*WlMXK3rs_scqKTRV41au7g.jpeg)

Now, that’s not the best user experience out there, is it?

So, how can we execute heavy code without blocking the UI and making the browser unresponsive? Well, the solution is asynchronous callbacks.

This will be explained in greater detail in Part 2 of the “How JavaScript actually works” tutorial: “[Inside the V8 engine + 5 tips on how to write optimized code](https://blog.sessionstack.com/how-javascript-works-inside-the-v8-engine-5-tips-on-how-to-write-optimized-code-ac089e62b12e)”.

In the meantime, if you’re having a hard time reproducing and understanding issues in your JavaScript apps, take a look at SessionStack. SessionStack records everything in your web apps: all DOM changes, user interactions, JavaScript exceptions, stack traces, failed network requests, and debug messages.

With SessionStack, you can replay issues in your web apps as videos and see everything that happened to your user.

There’s a free plan, no credit card is required. [Get started now](https://www.sessionstack.com/solutions/developers/?utm_source=medium&utm_medium=blog&utm_content=Post-1-overview-getStarted).

![](https://cdn-images-1.medium.com/max/800/1*kEQmoMuNBDfZKNSBh0tvRA.png)


출처: [How JavaScript works: an overview of the engine, the runtime, and the call stack](https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf)